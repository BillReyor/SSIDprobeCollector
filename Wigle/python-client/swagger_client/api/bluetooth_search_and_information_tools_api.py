# coding: utf-8

"""
    WiGLE API

    Search, upload, and integrate statistics from WiGLE. Use API Name+Token from https://wigle.net/account  # noqa: E501

    OpenAPI spec version: 3.1
    Contact: WiGLE-admin@wigle.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class BluetoothSearchAndInformationToolsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def detail(self, **kwargs):  # noqa: E501
        """Get details and observation records for a single network.  # noqa: E501

        Provide unique information for a Bluetooth network. API and session authentication default to a page size of 100 results/page. Number of daily queries allowed per user are throttled based on history and participation. Detail endpoints are NOT included in COMMAPI subscriptions at this time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detail(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str netid: The full Bluetooth Device ID to search
        :param str reverse_address: Reverse geocode for an approximate address
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detail_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.detail_with_http_info(**kwargs)  # noqa: E501
            return data

    def detail_with_http_info(self, **kwargs):  # noqa: E501
        """Get details and observation records for a single network.  # noqa: E501

        Provide unique information for a Bluetooth network. API and session authentication default to a page size of 100 results/page. Number of daily queries allowed per user are throttled based on history and participation. Detail endpoints are NOT included in COMMAPI subscriptions at this time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detail_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str netid: The full Bluetooth Device ID to search
        :param str reverse_address: Reverse geocode for an approximate address
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['netid', 'reverse_address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detail" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'netid' in params:
            query_params.append(('netid', params['netid']))  # noqa: E501
        if 'reverse_address' in params:
            query_params.append(('reverseAddress', params['reverse_address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bluetooth/detail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetSearchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search(self, **kwargs):  # noqa: E501
        """Search the WiGLE Bluetooth database.  # noqa: E501

        Query the WiGLE database for paginated results based on multiple criteria. API and session authentication default to a page size of 100 results/page. COMMAPI defaults to a page size of 25 with a maximum of 1000 results per return. Number of daily queries allowed per user are throttled based on history and participation. Search endpoints are the only feature included in COMMAPI subscriptions at this time.<br><br>To get next page of results put the previous request's searchAfter value as a parameter in the new request's searchAfter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str onlymine: Search only for points first discovered by the current user. Use any string to set, leave unset for general search. Can't be used with COMMAPI auth, since these are points you have locally.
        :param str notmine: Only search for networks first seen by other users
        :param float latrange1: Lesser of two latitudes by which to bound the search (specify both)
        :param float latrange2: Greater of two latitudes by which to bound the search (specify both)
        :param float longrange1: Lesser of two longitudes by which to bound the search (specify both)
        :param float longrange2: Greater of two longitudes by which to bound the search (specify both)
        :param str lastupdt: Filter points by how recently they've been updated, condensed date/time numeric string format 'yyyyMMdd[hhmm[ss]]'
        :param str start_trans_id: Earliest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str end_trans_id: Latest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str netid: Include only networks matching the string network BSSID, e.g. '0A:2C:EF:3D:25:1B' or '0A:2C:EF'. The first three octets are required.
        :param str name: Include only networks exactly matching the string network name.
        :param str namelike: Include only networks matching the string network name, allowing wildcards '%' (any string) and '_' (any character).
        :param str show_bt: Include BT networks
        :param str show_ble: Include BLE networks
        :param int min_qo_s: Minimum Quality of Signal (0-7).
        :param float variance: How tightly to bound queries against the provided latitude/longitude box. Value must be between 0.001 and 0.2. Intended for use with non-exact decimals and geocoded bounds.
        :param str house_number: Street address house number
        :param str road: Street address road
        :param str city: Street address city
        :param str region: Street address region
        :param str postal_code: Street address postal code
        :param str country: Street address country
        :param int results_per_page: How many results to return per request. Defaults to 25 for COMMAPI, 100 for site. Bounded at 1000 for COMMAPI, 100 for site.
        :param str search_after: Put in the previous page's searchAfter result to get the next page. Use this instead of 'first'
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_with_http_info(self, **kwargs):  # noqa: E501
        """Search the WiGLE Bluetooth database.  # noqa: E501

        Query the WiGLE database for paginated results based on multiple criteria. API and session authentication default to a page size of 100 results/page. COMMAPI defaults to a page size of 25 with a maximum of 1000 results per return. Number of daily queries allowed per user are throttled based on history and participation. Search endpoints are the only feature included in COMMAPI subscriptions at this time.<br><br>To get next page of results put the previous request's searchAfter value as a parameter in the new request's searchAfter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str onlymine: Search only for points first discovered by the current user. Use any string to set, leave unset for general search. Can't be used with COMMAPI auth, since these are points you have locally.
        :param str notmine: Only search for networks first seen by other users
        :param float latrange1: Lesser of two latitudes by which to bound the search (specify both)
        :param float latrange2: Greater of two latitudes by which to bound the search (specify both)
        :param float longrange1: Lesser of two longitudes by which to bound the search (specify both)
        :param float longrange2: Greater of two longitudes by which to bound the search (specify both)
        :param str lastupdt: Filter points by how recently they've been updated, condensed date/time numeric string format 'yyyyMMdd[hhmm[ss]]'
        :param str start_trans_id: Earliest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str end_trans_id: Latest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str netid: Include only networks matching the string network BSSID, e.g. '0A:2C:EF:3D:25:1B' or '0A:2C:EF'. The first three octets are required.
        :param str name: Include only networks exactly matching the string network name.
        :param str namelike: Include only networks matching the string network name, allowing wildcards '%' (any string) and '_' (any character).
        :param str show_bt: Include BT networks
        :param str show_ble: Include BLE networks
        :param int min_qo_s: Minimum Quality of Signal (0-7).
        :param float variance: How tightly to bound queries against the provided latitude/longitude box. Value must be between 0.001 and 0.2. Intended for use with non-exact decimals and geocoded bounds.
        :param str house_number: Street address house number
        :param str road: Street address road
        :param str city: Street address city
        :param str region: Street address region
        :param str postal_code: Street address postal code
        :param str country: Street address country
        :param int results_per_page: How many results to return per request. Defaults to 25 for COMMAPI, 100 for site. Bounded at 1000 for COMMAPI, 100 for site.
        :param str search_after: Put in the previous page's searchAfter result to get the next page. Use this instead of 'first'
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['onlymine', 'notmine', 'latrange1', 'latrange2', 'longrange1', 'longrange2', 'lastupdt', 'start_trans_id', 'end_trans_id', 'netid', 'name', 'namelike', 'show_bt', 'show_ble', 'min_qo_s', 'variance', 'house_number', 'road', 'city', 'region', 'postal_code', 'country', 'results_per_page', 'search_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'onlymine' in params:
            query_params.append(('onlymine', params['onlymine']))  # noqa: E501
        if 'notmine' in params:
            query_params.append(('notmine', params['notmine']))  # noqa: E501
        if 'latrange1' in params:
            query_params.append(('latrange1', params['latrange1']))  # noqa: E501
        if 'latrange2' in params:
            query_params.append(('latrange2', params['latrange2']))  # noqa: E501
        if 'longrange1' in params:
            query_params.append(('longrange1', params['longrange1']))  # noqa: E501
        if 'longrange2' in params:
            query_params.append(('longrange2', params['longrange2']))  # noqa: E501
        if 'lastupdt' in params:
            query_params.append(('lastupdt', params['lastupdt']))  # noqa: E501
        if 'start_trans_id' in params:
            query_params.append(('startTransID', params['start_trans_id']))  # noqa: E501
        if 'end_trans_id' in params:
            query_params.append(('endTransID', params['end_trans_id']))  # noqa: E501
        if 'netid' in params:
            query_params.append(('netid', params['netid']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'namelike' in params:
            query_params.append(('namelike', params['namelike']))  # noqa: E501
        if 'show_bt' in params:
            query_params.append(('showBt', params['show_bt']))  # noqa: E501
        if 'show_ble' in params:
            query_params.append(('showBle', params['show_ble']))  # noqa: E501
        if 'min_qo_s' in params:
            query_params.append(('minQoS', params['min_qo_s']))  # noqa: E501
        if 'variance' in params:
            query_params.append(('variance', params['variance']))  # noqa: E501
        if 'house_number' in params:
            query_params.append(('houseNumber', params['house_number']))  # noqa: E501
        if 'road' in params:
            query_params.append(('road', params['road']))  # noqa: E501
        if 'city' in params:
            query_params.append(('city', params['city']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'postal_code' in params:
            query_params.append(('postalCode', params['postal_code']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('resultsPerPage', params['results_per_page']))  # noqa: E501
        if 'search_after' in params:
            query_params.append(('searchAfter', params['search_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bluetooth/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetSearchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
