# coding: utf-8

"""
    WiGLE API

    Search, upload, and integrate statistics from WiGLE. Use API Name+Token from https://wigle.net/account  # noqa: E501

    OpenAPI spec version: 3.1
    Contact: WiGLE-admin@wigle.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class NetworkSearchAndInformationToolsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def comment(self, **kwargs):  # noqa: E501
        """Add a comment to a network  # noqa: E501

        provide custom information regarding a single network  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.comment(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str netid: The BSSID of the network for the comment, e.g. '0A:2C:EF:3D:25:1B'
        :param str comment: The comment to attach
        :return: NetCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.comment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.comment_with_http_info(**kwargs)  # noqa: E501
            return data

    def comment_with_http_info(self, **kwargs):  # noqa: E501
        """Add a comment to a network  # noqa: E501

        provide custom information regarding a single network  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.comment_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str netid: The BSSID of the network for the comment, e.g. '0A:2C:EF:3D:25:1B'
        :param str comment: The comment to attach
        :return: NetCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['netid', 'comment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method comment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'netid' in params:
            form_params.append(('netid', params['netid']))  # noqa: E501
        if 'comment' in params:
            form_params.append(('comment', params['comment']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/network/comment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detail1(self, **kwargs):  # noqa: E501
        """Get details and observation records for a single wifi or cell network  # noqa: E501

        Provide unique information for a WiFi or cell network to request detailed information. Providing a netId value searches WiFi, operator searches GSM, and system searches CDMA. Detail endpoints are NOT included in COMMAPI subscriptions at this time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detail1(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str netid: The WiFi Network BSSID to search
        :param int operator: GSM/LTE/WCDMA Operator ID
        :param int lac: GSM/LTE/WCDMA Location Area Code
        :param int cid: GSM/LTE/WCDMA Cell ID
        :param str type: Network Type: CDMA/GSM/LTE/WCDMA/WIFI
        :param int system: CDMA System ID
        :param int network: CDMA Network ID
        :param int basestation: CDMA Base Station ID
        :return: WiFiNetworkDetailResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detail1_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.detail1_with_http_info(**kwargs)  # noqa: E501
            return data

    def detail1_with_http_info(self, **kwargs):  # noqa: E501
        """Get details and observation records for a single wifi or cell network  # noqa: E501

        Provide unique information for a WiFi or cell network to request detailed information. Providing a netId value searches WiFi, operator searches GSM, and system searches CDMA. Detail endpoints are NOT included in COMMAPI subscriptions at this time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detail1_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str netid: The WiFi Network BSSID to search
        :param int operator: GSM/LTE/WCDMA Operator ID
        :param int lac: GSM/LTE/WCDMA Location Area Code
        :param int cid: GSM/LTE/WCDMA Cell ID
        :param str type: Network Type: CDMA/GSM/LTE/WCDMA/WIFI
        :param int system: CDMA System ID
        :param int network: CDMA Network ID
        :param int basestation: CDMA Base Station ID
        :return: WiFiNetworkDetailResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['netid', 'operator', 'lac', 'cid', 'type', 'system', 'network', 'basestation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detail1" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'netid' in params:
            query_params.append(('netid', params['netid']))  # noqa: E501
        if 'operator' in params:
            query_params.append(('operator', params['operator']))  # noqa: E501
        if 'lac' in params:
            query_params.append(('lac', params['lac']))  # noqa: E501
        if 'cid' in params:
            query_params.append(('cid', params['cid']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'system' in params:
            query_params.append(('system', params['system']))  # noqa: E501
        if 'network' in params:
            query_params.append(('network', params['network']))  # noqa: E501
        if 'basestation' in params:
            query_params.append(('basestation', params['basestation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/network/detail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WiFiNetworkDetailResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def geocode(self, **kwargs):  # noqa: E501
        """Get coordinates for an address for use in searching  # noqa: E501

        Relies on OpenStreetMap nominatim  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str addresscode: An address string, Street, City, State/Region, Country
        :return: NetworkGeocodingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.geocode_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.geocode_with_http_info(**kwargs)  # noqa: E501
            return data

    def geocode_with_http_info(self, **kwargs):  # noqa: E501
        """Get coordinates for an address for use in searching  # noqa: E501

        Relies on OpenStreetMap nominatim  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str addresscode: An address string, Street, City, State/Region, Country
        :return: NetworkGeocodingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['addresscode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method geocode" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'addresscode' in params:
            query_params.append(('addresscode', params['addresscode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/network/geocode', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkGeocodingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search2(self, **kwargs):  # noqa: E501
        """Search the WiGLE Wifi database.  # noqa: E501

        Query the WiGLE database for paginated results based on multiple criteria. API and session authentication default to a page size of 100 results/page. COMMAPI defaults to a page size of 25 with a maximum of 1000 results per return. Number of daily queries allowed per user are throttled based on history and participation.  Search endpoints are the only feature included in COMMAPI subscriptions at this time.<br><br>To get next page of results put the previous request's searchAfter value as a parameter in the new request's searchAfter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search2(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str onlymine: Search only for points first discovered by the current user. Use any string to set, leave unset for general search. Can't be used with COMMAPI auth, since these are points you have locally.
        :param str notmine: Only search for networks first seen by other users
        :param float latrange1: Lesser of two latitudes by which to bound the search (specify both)
        :param float latrange2: Greater of two latitudes by which to bound the search (specify both)
        :param float longrange1: Lesser of two longitudes by which to bound the search (specify both)
        :param float longrange2: Greater of two longitudes by which to bound the search (specify both)
        :param str lastupdt: Filter points by how recently they've been updated, condensed date/time numeric string format 'yyyyMMdd[hhmm[ss]]'
        :param str start_trans_id: Earliest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str end_trans_id: Latest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str encryption: Encryption detected: 'None', 'WEP', 'WPA', 'WPA2', 'WPA3', 'Unknown'. Case insensitive.
        :param bool freenet: Include only networks that have been marked as free access.
        :param bool paynet: Include only networks that have been marked as for-pay access.
        :param str netid: Include only networks matching the string network BSSID, e.g. '0A:2C:EF:3D:25:1B' or '0A:2C:EF'. The first three octets are required.
        :param str ssid: Include only networks exactly matching the string network name.
        :param str ssidlike: Include only networks matching the string network name, allowing wildcards '%' (any string) and '_' (any character).
        :param int min_qo_s: Minimum Quality of Signal (0-7).
        :param float variance: How tightly to bound queries against the provided latitude/longitude box. Value must be between 0.001 and 0.2. Intended for use with non-exact decimals and geocoded bounds.
        :param str house_number: Street address house number
        :param str road: Street address road
        :param str city: Street address city
        :param str region: Street address region
        :param str postal_code: Street address postal code
        :param str country: Street address country
        :param int results_per_page: How many results to return per request. Defaults to 25 for COMMAPI, 100 for site. Bounded at 1000 for COMMAPI, 100 for site.
        :param str search_after: Put in the previous page's searchAfter result to get the next page. Use this instead of 'first'
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search2_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search2_with_http_info(**kwargs)  # noqa: E501
            return data

    def search2_with_http_info(self, **kwargs):  # noqa: E501
        """Search the WiGLE Wifi database.  # noqa: E501

        Query the WiGLE database for paginated results based on multiple criteria. API and session authentication default to a page size of 100 results/page. COMMAPI defaults to a page size of 25 with a maximum of 1000 results per return. Number of daily queries allowed per user are throttled based on history and participation.  Search endpoints are the only feature included in COMMAPI subscriptions at this time.<br><br>To get next page of results put the previous request's searchAfter value as a parameter in the new request's searchAfter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search2_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str onlymine: Search only for points first discovered by the current user. Use any string to set, leave unset for general search. Can't be used with COMMAPI auth, since these are points you have locally.
        :param str notmine: Only search for networks first seen by other users
        :param float latrange1: Lesser of two latitudes by which to bound the search (specify both)
        :param float latrange2: Greater of two latitudes by which to bound the search (specify both)
        :param float longrange1: Lesser of two longitudes by which to bound the search (specify both)
        :param float longrange2: Greater of two longitudes by which to bound the search (specify both)
        :param str lastupdt: Filter points by how recently they've been updated, condensed date/time numeric string format 'yyyyMMdd[hhmm[ss]]'
        :param str start_trans_id: Earliest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str end_trans_id: Latest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str encryption: Encryption detected: 'None', 'WEP', 'WPA', 'WPA2', 'WPA3', 'Unknown'. Case insensitive.
        :param bool freenet: Include only networks that have been marked as free access.
        :param bool paynet: Include only networks that have been marked as for-pay access.
        :param str netid: Include only networks matching the string network BSSID, e.g. '0A:2C:EF:3D:25:1B' or '0A:2C:EF'. The first three octets are required.
        :param str ssid: Include only networks exactly matching the string network name.
        :param str ssidlike: Include only networks matching the string network name, allowing wildcards '%' (any string) and '_' (any character).
        :param int min_qo_s: Minimum Quality of Signal (0-7).
        :param float variance: How tightly to bound queries against the provided latitude/longitude box. Value must be between 0.001 and 0.2. Intended for use with non-exact decimals and geocoded bounds.
        :param str house_number: Street address house number
        :param str road: Street address road
        :param str city: Street address city
        :param str region: Street address region
        :param str postal_code: Street address postal code
        :param str country: Street address country
        :param int results_per_page: How many results to return per request. Defaults to 25 for COMMAPI, 100 for site. Bounded at 1000 for COMMAPI, 100 for site.
        :param str search_after: Put in the previous page's searchAfter result to get the next page. Use this instead of 'first'
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['onlymine', 'notmine', 'latrange1', 'latrange2', 'longrange1', 'longrange2', 'lastupdt', 'start_trans_id', 'end_trans_id', 'encryption', 'freenet', 'paynet', 'netid', 'ssid', 'ssidlike', 'min_qo_s', 'variance', 'house_number', 'road', 'city', 'region', 'postal_code', 'country', 'results_per_page', 'search_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search2" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'onlymine' in params:
            query_params.append(('onlymine', params['onlymine']))  # noqa: E501
        if 'notmine' in params:
            query_params.append(('notmine', params['notmine']))  # noqa: E501
        if 'latrange1' in params:
            query_params.append(('latrange1', params['latrange1']))  # noqa: E501
        if 'latrange2' in params:
            query_params.append(('latrange2', params['latrange2']))  # noqa: E501
        if 'longrange1' in params:
            query_params.append(('longrange1', params['longrange1']))  # noqa: E501
        if 'longrange2' in params:
            query_params.append(('longrange2', params['longrange2']))  # noqa: E501
        if 'lastupdt' in params:
            query_params.append(('lastupdt', params['lastupdt']))  # noqa: E501
        if 'start_trans_id' in params:
            query_params.append(('startTransID', params['start_trans_id']))  # noqa: E501
        if 'end_trans_id' in params:
            query_params.append(('endTransID', params['end_trans_id']))  # noqa: E501
        if 'encryption' in params:
            query_params.append(('encryption', params['encryption']))  # noqa: E501
        if 'freenet' in params:
            query_params.append(('freenet', params['freenet']))  # noqa: E501
        if 'paynet' in params:
            query_params.append(('paynet', params['paynet']))  # noqa: E501
        if 'netid' in params:
            query_params.append(('netid', params['netid']))  # noqa: E501
        if 'ssid' in params:
            query_params.append(('ssid', params['ssid']))  # noqa: E501
        if 'ssidlike' in params:
            query_params.append(('ssidlike', params['ssidlike']))  # noqa: E501
        if 'min_qo_s' in params:
            query_params.append(('minQoS', params['min_qo_s']))  # noqa: E501
        if 'variance' in params:
            query_params.append(('variance', params['variance']))  # noqa: E501
        if 'house_number' in params:
            query_params.append(('houseNumber', params['house_number']))  # noqa: E501
        if 'road' in params:
            query_params.append(('road', params['road']))  # noqa: E501
        if 'city' in params:
            query_params.append(('city', params['city']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'postal_code' in params:
            query_params.append(('postalCode', params['postal_code']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('resultsPerPage', params['results_per_page']))  # noqa: E501
        if 'search_after' in params:
            query_params.append(('searchAfter', params['search_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/network/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetSearchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
