# coding: utf-8

"""
    WiGLE API

    Search, upload, and integrate statistics from WiGLE. Use API Name+Token from https://wigle.net/account  # noqa: E501

    OpenAPI spec version: 3.1
    Contact: WiGLE-admin@wigle.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CellSearchAndInformationToolsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def mcc_mnc(self, **kwargs):  # noqa: E501
        """Get MCC and MNC codes for Cellular networks  # noqa: E501

        Get metadata for cell networks - optionally filter by country and network codes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mcc_mnc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mcc: MCC to filter
        :param str mnc: MNC to filter
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mcc_mnc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.mcc_mnc_with_http_info(**kwargs)  # noqa: E501
            return data

    def mcc_mnc_with_http_info(self, **kwargs):  # noqa: E501
        """Get MCC and MNC codes for Cellular networks  # noqa: E501

        Get metadata for cell networks - optionally filter by country and network codes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mcc_mnc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mcc: MCC to filter
        :param str mnc: MNC to filter
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mcc', 'mnc']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mcc_mnc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mcc' in params:
            query_params.append(('mcc', params['mcc']))  # noqa: E501
        if 'mnc' in params:
            query_params.append(('mnc', params['mnc']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cell/mccMnc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search1(self, **kwargs):  # noqa: E501
        """Search the WiGLE Cell database.  # noqa: E501

        Query the WiGLE database for paginated results based on multiple criteria. API and session authentication default to a page size of 100 results/page. COMMAPI defaults to a page size of 25 with a maximum of 1000 results per return. Number of daily queries allowed per user are throttled based on history and participation.  Search endpoints are the only feature included in COMMAPI subscriptions at this time.<br><br>To get next page of results put the previous request's searchAfter value as a parameter in the new request's searchAfter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search1(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str onlymine: Search only for points first discovered by the current user. Use any string to set, leave unset for general search. Can't be used with COMMAPI auth, since these are points you have locally.
        :param str notmine: Only search for networks first seen by other users
        :param float latrange1: Lesser of two latitudes by which to bound the search (specify both)
        :param float latrange2: Greater of two latitudes by which to bound the search (specify both)
        :param float longrange1: Lesser of two longitudes by which to bound the search (specify both)
        :param float longrange2: Greater of two longitudes by which to bound the search (specify both)
        :param str lastupdt: Filter points by how recently they've been updated, condensed date/time numeric string format 'yyyyMMdd[hhmm[ss]]'
        :param str start_trans_id: Earliest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str end_trans_id: Latest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str cell_op: Cell Operator (GSM/LTE/WCDMA) or System (CDMA) ID parameter by which to filter
        :param str cell_net: Cell LAC (GSM/LTE/WCDMA) or Network (CDMA) ID parameter by which to filter
        :param str cell_id: Cell ID(GSM/LTE/WCDMA) or Basestation (CDMA) parameter by which to filter
        :param str ssid: Include only cell towers exactly matching the string network name.
        :param str ssidlike: Include only cell towers matching the string network name, allowing wildcards '%' (any string) and '_' (any character).
        :param int min_qo_s: Minimum Quality of Signal (0-7).
        :param str show_gsm: Include GSM cell networks
        :param str show_cdma: Include CDMA cell networks
        :param str show_lte: Include LTE cell networks
        :param str show_wcdma: Include WCDMA cell networks
        :param float variance: How tightly to bound queries against the provided latitude/longitude box. Value must be between 0.001 and 0.2. Intended for use with non-exact decimals and geocoded bounds.
        :param str house_number: Street address house number
        :param str road: Street address road
        :param str city: Street address city
        :param str region: Street address region
        :param str postal_code: Street address postal code
        :param str country: Street address country
        :param int results_per_page: How many results to return per request. Defaults to 25 for COMMAPI, 100 for site. Bounded at 1000 for COMMAPI, 100 for site.
        :param str search_after: Put in the previous page's searchAfter result to get the next page. Use this instead of 'first'
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search1_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search1_with_http_info(**kwargs)  # noqa: E501
            return data

    def search1_with_http_info(self, **kwargs):  # noqa: E501
        """Search the WiGLE Cell database.  # noqa: E501

        Query the WiGLE database for paginated results based on multiple criteria. API and session authentication default to a page size of 100 results/page. COMMAPI defaults to a page size of 25 with a maximum of 1000 results per return. Number of daily queries allowed per user are throttled based on history and participation.  Search endpoints are the only feature included in COMMAPI subscriptions at this time.<br><br>To get next page of results put the previous request's searchAfter value as a parameter in the new request's searchAfter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search1_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str onlymine: Search only for points first discovered by the current user. Use any string to set, leave unset for general search. Can't be used with COMMAPI auth, since these are points you have locally.
        :param str notmine: Only search for networks first seen by other users
        :param float latrange1: Lesser of two latitudes by which to bound the search (specify both)
        :param float latrange2: Greater of two latitudes by which to bound the search (specify both)
        :param float longrange1: Lesser of two longitudes by which to bound the search (specify both)
        :param float longrange2: Greater of two longitudes by which to bound the search (specify both)
        :param str lastupdt: Filter points by how recently they've been updated, condensed date/time numeric string format 'yyyyMMdd[hhmm[ss]]'
        :param str start_trans_id: Earliest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str end_trans_id: Latest transid by which to bound (year-level precision only), format 'yyyyMMdd-00000'
        :param str cell_op: Cell Operator (GSM/LTE/WCDMA) or System (CDMA) ID parameter by which to filter
        :param str cell_net: Cell LAC (GSM/LTE/WCDMA) or Network (CDMA) ID parameter by which to filter
        :param str cell_id: Cell ID(GSM/LTE/WCDMA) or Basestation (CDMA) parameter by which to filter
        :param str ssid: Include only cell towers exactly matching the string network name.
        :param str ssidlike: Include only cell towers matching the string network name, allowing wildcards '%' (any string) and '_' (any character).
        :param int min_qo_s: Minimum Quality of Signal (0-7).
        :param str show_gsm: Include GSM cell networks
        :param str show_cdma: Include CDMA cell networks
        :param str show_lte: Include LTE cell networks
        :param str show_wcdma: Include WCDMA cell networks
        :param float variance: How tightly to bound queries against the provided latitude/longitude box. Value must be between 0.001 and 0.2. Intended for use with non-exact decimals and geocoded bounds.
        :param str house_number: Street address house number
        :param str road: Street address road
        :param str city: Street address city
        :param str region: Street address region
        :param str postal_code: Street address postal code
        :param str country: Street address country
        :param int results_per_page: How many results to return per request. Defaults to 25 for COMMAPI, 100 for site. Bounded at 1000 for COMMAPI, 100 for site.
        :param str search_after: Put in the previous page's searchAfter result to get the next page. Use this instead of 'first'
        :return: NetSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['onlymine', 'notmine', 'latrange1', 'latrange2', 'longrange1', 'longrange2', 'lastupdt', 'start_trans_id', 'end_trans_id', 'cell_op', 'cell_net', 'cell_id', 'ssid', 'ssidlike', 'min_qo_s', 'show_gsm', 'show_cdma', 'show_lte', 'show_wcdma', 'variance', 'house_number', 'road', 'city', 'region', 'postal_code', 'country', 'results_per_page', 'search_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search1" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'onlymine' in params:
            query_params.append(('onlymine', params['onlymine']))  # noqa: E501
        if 'notmine' in params:
            query_params.append(('notmine', params['notmine']))  # noqa: E501
        if 'latrange1' in params:
            query_params.append(('latrange1', params['latrange1']))  # noqa: E501
        if 'latrange2' in params:
            query_params.append(('latrange2', params['latrange2']))  # noqa: E501
        if 'longrange1' in params:
            query_params.append(('longrange1', params['longrange1']))  # noqa: E501
        if 'longrange2' in params:
            query_params.append(('longrange2', params['longrange2']))  # noqa: E501
        if 'lastupdt' in params:
            query_params.append(('lastupdt', params['lastupdt']))  # noqa: E501
        if 'start_trans_id' in params:
            query_params.append(('startTransID', params['start_trans_id']))  # noqa: E501
        if 'end_trans_id' in params:
            query_params.append(('endTransID', params['end_trans_id']))  # noqa: E501
        if 'cell_op' in params:
            query_params.append(('cell_op', params['cell_op']))  # noqa: E501
        if 'cell_net' in params:
            query_params.append(('cell_net', params['cell_net']))  # noqa: E501
        if 'cell_id' in params:
            query_params.append(('cell_id', params['cell_id']))  # noqa: E501
        if 'ssid' in params:
            query_params.append(('ssid', params['ssid']))  # noqa: E501
        if 'ssidlike' in params:
            query_params.append(('ssidlike', params['ssidlike']))  # noqa: E501
        if 'min_qo_s' in params:
            query_params.append(('minQoS', params['min_qo_s']))  # noqa: E501
        if 'show_gsm' in params:
            query_params.append(('showGsm', params['show_gsm']))  # noqa: E501
        if 'show_cdma' in params:
            query_params.append(('showCdma', params['show_cdma']))  # noqa: E501
        if 'show_lte' in params:
            query_params.append(('showLte', params['show_lte']))  # noqa: E501
        if 'show_wcdma' in params:
            query_params.append(('showWcdma', params['show_wcdma']))  # noqa: E501
        if 'variance' in params:
            query_params.append(('variance', params['variance']))  # noqa: E501
        if 'house_number' in params:
            query_params.append(('houseNumber', params['house_number']))  # noqa: E501
        if 'road' in params:
            query_params.append(('road', params['road']))  # noqa: E501
        if 'city' in params:
            query_params.append(('city', params['city']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'postal_code' in params:
            query_params.append(('postalCode', params['postal_code']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('resultsPerPage', params['results_per_page']))  # noqa: E501
        if 'search_after' in params:
            query_params.append(('searchAfter', params['search_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cell/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetSearchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
